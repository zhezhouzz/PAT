open Zdatatype
open AutomataLibrary
open Common
open Ast
open SFA

let se_to_regex x = MultiChar (CharSet.singleton x)

let linear_regex_to_regex = function
  | LChar se -> se_to_regex se
  | LMultiChar cs -> MultiChar cs
  | LStar cs -> Star cs

let linear_regex_list_to_regex l = seq (List.map linear_regex_to_regex l)

let regex_to_linear_regex_list r =
  let rec aux = function
    | Empty -> []
    | Eps -> [ [] ]
    | MultiChar cs -> [ [ LMultiChar cs ] ]
    | Star cs -> [ [ LStar cs ] ]
    | Seq [] -> [ [] ]
    | Seq (x :: xs) ->
        let x = aux x in
        let xs = aux (Seq xs) in
        let res =
          List.fold_left (fun res x -> res @ List.map (fun y -> x @ y) xs) [] x
        in
        res
    | Alt (x, y) -> aux x @ aux y
    | Inters _ | Comple _ -> _die_with [%here] "never"
  in
  aux r

let mk_se ctx op f =
  let vs = _get_force [%here] ctx op in
  let vs =
    match vs with
    | Nt.Ty_record { fds; _ } -> fds
    | _ -> _die_with [%here] "unimp"
  in
  { op; vs; phi = f vs }

let mk_se_with_args ctx op args =
  mk_se ctx op (fun vs ->
      smart_and
        (List.map2
           (fun x y -> lit_to_prop (mk_lit_eq_lit [%here] (AVar x) (AVar y)))
           vs args))

let plan_elem_to_regex ctx = function
  | LineAct { aop; aargs; _ } ->
      MultiChar (CharSet.singleton (mk_se_with_args ctx aop aargs))
  | LineMultiChar cs -> MultiChar cs
  | LineStar r -> r

let line_to_regex ctx l = seq (List.map (plan_elem_to_regex ctx) l)

let prop_to_conjuncts phi =
  let rec aux prop =
    match prop with
    | Lit x -> [ Lit x ]
    | And xs -> List.concat_map aux xs
    | _ -> [ prop ]
  in
  aux phi

let get_assigns conjs vs =
  let assignments =
    List.filter_map
      (fun x ->
        let l = List.filter_map (fun prop -> is_eq_phi x prop) conjs in
        match l with
        | [] -> None
        | [ AVar y ] -> Some y
        | _ -> _die_with [%here] "never")
      vs
  in
  if List.length assignments < List.length vs then None else Some assignments

let try_recover_act actMap { op; vs; phi } =
  match get_assigns (prop_to_conjuncts phi) vs with
  | Some aargs ->
      let act = { aop = op; aargs; aid = -1 } in
      let act =
        match ActMap.find_opt act actMap with
        | Some id -> { act with aid = id }
        | None -> _die_with [%here] "never"
      in
      let phi =
        List.fold_left
          (fun phi (x, y) -> subst_prop_instance x.x (AVar y) phi)
          phi
        @@ List.combine vs aargs
      in
      let phi = simpl_eq_in_prop phi in
      Some (act, phi)
  | None -> None

let linear_regex_to_line_elem actMap prop = function
  | LChar se -> (
      match try_recover_act actMap se with
      | None -> (prop, LineMultiChar (CharSet.singleton se))
      | Some (act, phi) -> (smart_add_to phi prop, LineAct act))
  | LMultiChar cs -> (prop, LineMultiChar cs)
  | LStar cs -> (prop, LineStar cs)

let linear_regex_to_lines actMap prop r =
  List.fold_left
    (fun (prop, line) r ->
      let prop, elem = linear_regex_to_line_elem actMap prop r in
      (prop, line @ [ elem ]))
    (prop, []) r

let regex_to_lines actMap prop r =
  let ls = regex_to_linear_regex_list r in
  List.map (linear_regex_to_lines actMap prop) ls

let layout_line_elem_aux omit = function
  | LineAct { aid; aop; aargs } ->
      let op = spf "%i-%s" aid aop in
      tpEvent (spf "%s(%s)" op (layout_qvs aargs))
  | LineStar r -> if omit then "â–¡*" else SFA.layout_regex (Star r)
  | LineMultiChar cs -> SFA.layout_regex (MultiChar cs)

let layout_line = List.split_by ";" (layout_line_elem_aux false)
let omit_layout_line = List.split_by ";" (layout_line_elem_aux true)

let line_get_acts line =
  List.filter_map (function LineAct act -> Some act | _ -> None) line.elems

let get_aids line = List.map (fun e -> e.aid) (line_get_acts line)

let fresh_aid plan =
  List.fold_left
    (fun max id -> if id >= max then id + 1 else max)
    0 (get_aids plan.line)

(* let left_most_se plan = match get_acts plan with [] -> None | x :: _ -> Some x

let right_most_se plan =
  let* pre, cur, post = left_most_se (List.rev plan) in
  let () =
    Pp.printf "@{<green>right most@} se[%s] in %s\n" (layout_sevent cur)
      (layout plan)
  in
  Some (List.rev post, cur, List.rev pre) *)

let inter_lines (ctx, actMap) line1 line2 =
  let r1 = line_to_regex ctx line1 in
  let r2 = line_to_regex ctx line2 in
  let r = inter r1 r2 in
  let r = SFA.(dfa_to_reg @@ minimize @@ compile_regex_to_dfa r) in
  let ls = regex_to_lines actMap mk_true r in
  ls

let smart_and_se se1 elem =
  let () =
    _log "plan" @@ fun _ ->
    Pp.printf "@{<bold>smart_and_se:@} %s --> %s\n" (layout_sevent se1)
      (layout_elem elem)
  in
  let { op = op1; vs = vs1; phi = phi_1 } = se1 in
  match elem with
  | LineStarInv _ | LineStar _ -> _die_with [%here] "never"
  | PlanSe se ->
      let { op = op2; phi = phi_2; _ } = se in
      if String.equal op1 op2 then
        Some (PlanSe { op = op1; vs = vs1; phi = smart_add_to phi_1 phi_2 })
      else None
  | LineAct { op = op2; args } ->
      if String.equal op1 op2 then
        let phi_1' =
          List.fold_right
            (fun (x, y) -> subst_prop_instance x.x (AVar y))
            (_safe_combine [%here] vs1 args)
            phi_1
        in
        let () =
          _log "plan" @@ fun _ ->
          Pp.printf "op: %s\n" op1;
          Pp.printf "vs1: %s\n" (layout_qvs vs1);
          Pp.printf "args: %s\n" (layout_qvs args);
          Pp.printf "phi_1': %s\n" (layout_prop phi_1')
        in
        Some (LineActBuffer { op = op2; args; phi = phi_1' })
      else None
  | LineActBuffer { op = op2; args; phi = phi_2 } ->
      if String.equal op1 op2 then
        let phi_1' =
          List.fold_right
            (fun (x, y) -> subst_prop_instance x.x (AVar y))
            (_safe_combine [%here] vs1 args)
            phi_1
        in
        Some (LineActBuffer { op = op2; args; phi = smart_add_to phi_1' phi_2 })
      else None

let smart_and_se_in_cs cs cur =
  SFA.CharSet.fold
    (fun se -> function None -> smart_and_se se cur | Some res -> Some res)
    cs None

let single_insert elem trace =
  let () =
    _log "plan" @@ fun _ ->
    Printf.printf "insert (%s) in %s\n" (omit_layout_elem elem)
      (omit_layout trace)
  in
  (* let se = (elem_to_se ctx) elem in *)
  let rec aux (res, pre) ppp =
    let () =
      _log "plan" @@ fun _ ->
      Pp.printf "@{<bold>insert in:@}: %s\n" (omit_layout_plan ppp)
    in
    let () =
      _log "plan" @@ fun _ ->
      List.iter
        (fun (pre, cur, post) ->
          Pp.printf "@{<bold>insert result:@}: [%s] %s [%s]\n" (omit_layout pre)
            (layout_elem cur) (omit_layout post))
        res
    in
    match ppp with
    | [] -> res
    | LineStar _ :: _ -> _die_with [%here] "unimp"
    | (LineStarInv cs as x) :: rest -> (
        match smart_and_se_in_cs cs elem with
        | Some elem' ->
            let res' = (pre @ [ x ], elem', [ x ] @ rest) in
            aux (res' :: res, pre @ [ x ]) rest
        | None ->
            aux (res, pre @ [ x ]) rest
            (* if check_regex_include (se_to_regex se, MultiChar cs) then *)
            (*   let res' = (pre @ [ x ], se, [ x ] @ rest) in *)
            (*   aux (res' :: res, pre @ [ x ]) rest *)
            (* else aux (res, pre @ [ x ]) rest *))
    | ((LineAct _ | LineActBuffer _) as elem') :: rest -> (
        (* let () = *)
        (*   _log "plan" @@ fun _ -> *)
        (*   Printf.printf "<><>elem: %s\n" (omit_layout_elem elem) *)
        (* in *)
        match elem with
        | PlanSe cur when String.equal cur.op "eBecomeLeader" -> (
            match smart_and_se cur elem' with
            | None -> aux (res, pre @ [ elem' ]) rest
            | Some elem'' ->
                aux ((pre, elem'', rest) :: res, pre @ [ elem' ]) rest)
        | _ -> aux (res, pre @ [ elem' ]) rest)
    (* | LineActBuffer _ :: _ -> _die_with [%here] "never" *)
    | PlanSe cur :: rest -> (
        match smart_and_se cur elem with
        | Some elem' ->
            aux ((pre, elem', rest) :: res, pre @ [ PlanSe cur ]) rest
        | None -> aux (res, pre @ [ PlanSe cur ]) rest)
    (* if check_regex_include (se_to_regex elem', se_to_regex cur') *)
    (* then aux ((pre, elem, rest) :: res, pre @ [ PlanSe cur ]) rest *)
    (* else aux (res, pre @ [ PlanSe cur ]) rest *)
  in
  let res = aux ([], []) trace in
  let () =
    _log "plan" @@ fun _ ->
    List.iter
      (fun (pre, cur, post) ->
        Pp.printf "@{<bold>Insert Result:@}: %s -- %s -- %s\n" (layout pre)
          (layout_elem cur) (layout post))
      res
  in
  res

let rec insert elems trace =
  (* let () = *)
  (*   Printf.printf "insert [%s] in %s\n" *)
  (*     (List.split_by_comma layout_elem elems) *)
  (*     (layout trace) *)
  (* in *)
  match elems with
  | [] -> [ trace ]
  | [ se ] ->
      List.map (fun (a, b, c) -> a @ [ b ] @ c) @@ single_insert se trace
  | se :: rest ->
      let l = single_insert se trace in
      List.concat_map
        (fun (a, b, trace) ->
          let trace' = insert rest trace in
          List.map (fun c -> a @ [ b ] @ c) trace')
        l

let comple_cs cs cs' =
  let open SFA in
  let cs =
    CharSet.filter_map
      (fun { op; vs; phi } ->
        let phis =
          CharSet.fold
            (fun se' phis ->
              if String.equal op se'.op then se'.phi :: phis else phis)
            cs' []
        in
        let phi = smart_add_to phi (smart_not (smart_or phis)) in
        Some { op; vs; phi })
      cs
  in
  cs

let inter_cs cs1 cs2 =
  let open SFA in
  let cs =
    CharSet.filter_map
      (fun { op; vs; phi } ->
        let phis =
          CharSet.fold
            (fun se' phis ->
              if String.equal op se'.op then se'.phi :: phis else phis)
            cs2 []
        in
        let phi = smart_add_to phi (smart_or phis) in
        if is_false phi then None else Some { op; vs; phi })
      cs1
  in
  cs

let rec merge_plan_elem elem1 elem2 =
  let res =
    match (elem1, elem2) with
    | LineStar _, _ | _, LineStar _ -> _die_with [%here] "unimp"
    | LineStarInv cs1, LineStarInv cs2 -> Some (LineStarInv (inter_cs cs1 cs2))
    | LineStarInv cs1, _ -> smart_and_se_in_cs cs1 elem2
    | _, LineStarInv _ -> merge_plan_elem elem2 elem1
    | PlanSe cur, _ -> smart_and_se cur elem2
    | _, PlanSe _ -> merge_plan_elem elem2 elem1
    | (LineAct _ | LineActBuffer _), _ -> None
  in
  let () =
    _log "plan" @@ fun _ ->
    Pp.printf "@{<bold>merge-elem@} %s @{<bold>with@} %s\n"
      (omit_layout_elem elem1) (omit_layout_elem elem2)
  in
  let () =
    _log "plan" @@ fun _ ->
    Pp.printf "@{<bold>res merge-elem@} %s\n"
      (layout_option omit_layout_elem res)
  in
  res

let trace_sanity_check tab =
  let rec aux seen = function
    | [] -> true
    | x :: l -> (
        match Hashtbl.find tab x with
        | LineAct _ | LineActBuffer _ | PlanSe _ ->
            if IntSet.mem x seen then false else aux (IntSet.add x seen) l
        | _ -> aux seen l)
  in
  aux IntSet.empty

let case_sanity_check (tab1, tab2) case =
  let l1, l2 = List.split case in
  trace_sanity_check tab1 l1 && trace_sanity_check tab2 l2

let merge_plan l1 l2 =
  let () =
    _log "plan" @@ fun _ ->
    Pp.printf "@{<bold>>>>merge@} %s @{<bold>with@} %s\n" (omit_layout_plan l1)
      (omit_layout_plan l2)
  in
  let mk_tab l =
    let tab = Hashtbl.create (List.length l + 1) in
    let res =
      List.fold_lefti
        (fun res idx elem ->
          let () = Hashtbl.add tab idx elem in
          match elem with
          | LineActBuffer _ | LineAct _ | PlanSe _ -> res @ [ idx ]
          | _ -> res)
        [] l
    in
    (tab, res)
  in
  let num1, num2 = map2 List.length (l1, l2) in
  let tab1, l1 = mk_tab l1 in
  let tab2, l2 = mk_tab l2 in
  let cons_multi e l = List.map (fun l -> e :: l) l in
  let rec mk_seqence (l1, l2) =
    match (l1, l2) with
    | [], _ -> [ List.map (fun r -> (None, Some r)) l2 ]
    | _, [] -> [ List.map (fun l -> (Some l, None)) l1 ]
    | id1 :: l1, id2 :: l2 ->
        let res1 = cons_multi (Some id1, Some id2) @@ mk_seqence (l1, l2) in
        let res2 = cons_multi (Some id1, None) @@ mk_seqence (l1, id2 :: l2) in
        let res3 = cons_multi (None, Some id2) @@ mk_seqence (id1 :: l1, l2) in
        res1 @ res2 @ res3
  in
  (* let rec extend num (idx, l) = *)
  (*   if idx >= num then [] *)
  (*   else *)
  (*     match l with *)
  (*     | [] -> [ [] ] *)
  (*     | None :: l -> *)
  (*         cons_multi idx (extend num (idx, l)) *)
  (*         @ cons_multi idx (extend num (idx + 1, l)) *)
  (*         @ extend num (idx + 1, None :: l) *)
  (*     | Some idx' :: l -> if idx >= idx' then [] else extend num (idx' + 1, l) *)
  (* in *)
  (* let extend2 l = *)
  (*   let l1, l2 = List.split l in *)
  (*   let l1 = extend num1 (0, l1) in *)
  (*   let l2 = extend num2 (0, l2) in *)
  (*   let l = List.cross l1 l2 in *)
  (*   List.map (fun (x, y) -> List.combine x y) l *)
  (* in *)
  let l = mk_seqence (l1, l2) in
  let () =
    let layout_one = layout_option string_of_int in
    List.iteri
      (fun idx l ->
        Pp.printf "case[%i]: %s\n" idx
          (List.split_by_comma
             (fun (x, y) -> spf "(%s,%s)" (layout_one x) (layout_one y))
             l))
      l
  in
  (* let l = List.concat_map extend2 l in *)
  let rec fill (idx1, idx2) l =
    if idx1 >= num1 || idx2 >= num2 then []
    else if idx1 == num1 - 1 && idx2 == num2 - 1 then [ [ (idx1, idx2) ] ]
    else
      match l with
      | [] ->
          cons_multi (idx1, idx2) (fill (idx1 + 1, idx2 + 1) l)
          @ cons_multi (idx1, idx2) (fill (idx1, idx2 + 1) l)
          @ cons_multi (idx1, idx2) (fill (idx1 + 1, idx2) l)
      | (None, None) :: _ -> _die [%here]
      | (Some idx1', None) :: l' ->
          if idx1 > idx1' then []
          else if idx1 == idx1' - 1 then
            (cons_multi (idx1, idx2)
            @@ cons_multi (idx1', idx2) (fill (idx1' + 1, idx2) l'))
            @ cons_multi (idx1, idx2) (fill (idx1, idx2 + 1) l)
          else
            cons_multi (idx1, idx2) (fill (idx1 + 1, idx2 + 1) l)
            @ cons_multi (idx1, idx2) (fill (idx1, idx2 + 1) l)
            @ cons_multi (idx1, idx2) (fill (idx1 + 1, idx2) l)
      | (None, Some idx2') :: l' ->
          if idx2 >= idx2' then []
          else if idx2 == idx2' - 1 then
            (cons_multi (idx1, idx2)
            @@ cons_multi (idx1, idx2') (fill (idx1, idx2' + 1) l'))
            @ cons_multi (idx1, idx2) (fill (idx1 + 1, idx2) l)
          else
            cons_multi (idx1, idx2) (fill (idx1 + 1, idx2 + 1) l)
            @ cons_multi (idx1, idx2) (fill (idx1, idx2 + 1) l)
            @ cons_multi (idx1, idx2) (fill (idx1 + 1, idx2) l)
      | (Some idx1', Some idx2') :: l' ->
          if idx1 >= idx1' || idx2 >= idx2' then []
          else if idx1 == idx1' - 1 && idx2 == idx2' - 1 then
            cons_multi (idx1, idx2)
            @@ cons_multi (idx1', idx2') (fill (idx1' + 1, idx2' + 1) l')
          else
            cons_multi (idx1, idx2) (fill (idx1 + 1, idx2 + 1) l)
            @ cons_multi (idx1, idx2) (fill (idx1, idx2 + 1) l)
            @ cons_multi (idx1, idx2) (fill (idx1 + 1, idx2) l)
  in
  let l = List.concat_map (fill (0, 0)) l in
  let l = List.filter (case_sanity_check (tab1, tab2)) l in
  let () =
    Hashtbl.iter
      (fun idx elem -> Pp.printf "tab1[%i]: %s\n" idx (omit_layout_elem elem))
      tab1
  in
  let () =
    Hashtbl.iter
      (fun idx elem -> Pp.printf "tab2[%i]: %s\n" idx (omit_layout_elem elem))
      tab2
  in
  let () =
    List.iteri
      (fun idx l ->
        Pp.printf "case[%i]: %s\n" idx
          (List.split_by_comma (fun (x, y) -> spf "(%i,%i)" x y) l))
      l
  in
  let rec f res = function
    | [] -> Some res
    | (i, j) :: l ->
        let e1 = Hashtbl.find tab1 i in
        let e2 = Hashtbl.find tab2 j in
        let* e = merge_plan_elem e1 e2 in
        f (res @ [ e ]) l
  in
  let res = List.filter_map (f []) l in
  let res =
    List.sort (fun l1 l2 -> compare (List.length l1) (List.length l2)) res
  in
  (* let choose_less ll = *)
  (*   let min_len = *)
  (*     List.fold_left *)
  (*       (fun res l -> *)
  (*         let len = List.length l in *)
  (*         match res with *)
  (*         | None -> Some len *)
  (*         | Some res -> if len < res then Some len else Some res) *)
  (*       None ll *)
  (*   in *)
  (*   match min_len with *)
  (*   | None -> ll *)
  (*   | Some len -> List.filter (fun l -> len == List.length l) ll *)
  (* in *)
  (* let () = *)
  (*   List.iteri *)
  (*     (fun idx l -> Pp.printf "@{<bold>l[%i]:@} %s\n" idx (omit_layout l)) *)
  (*     res *)
  (* in *)
  (* let res = choose_less res in *)
  let () =
    List.iteri
      (fun idx l -> Pp.printf "@{<bold>res[%i]:@} %s\n" idx (omit_layout l))
      res
  in
  res

let elem_drop = function
  | LineActBuffer { op; args; _ } -> LineAct { op; args }
  | _ as v -> v

let eq_plan_elem a b = equal_plan_elem (elem_drop a) (elem_drop b)

let divide_by_elem elem trace =
  let rec aux pre = function
    | [] -> _die_with [%here] "never"
    | x :: post ->
        if eq_plan_elem elem x then (pre, x, post) else aux (pre @ [ x ]) post
  in
  aux [] trace

let parallel_interleaving l =
  let l = None :: List.map (fun x -> Some x) l in
  let l = List.permutation l in
  let rec aux pre = function
    | [] -> (pre, [])
    | None :: res -> (pre, List.filter_map (fun x -> x) res)
    | Some x :: res -> aux (pre @ [ x ]) res
  in
  List.map (aux []) l

let msubst_lit m = List.fold_right (fun (x, lit) -> subst_lit_instance x lit) m

let subst_value x value = function
  | VVar y -> if String.equal x y.x then value else VVar y
  | VConst c -> VConst c
  | VCStlcTy ty -> VCStlcTy ty
  | VCIntList xs -> VCIntList xs

let lit_to_value loc = function
  | AVar x -> VVar x
  | AC c -> VConst c
  | _ -> _die loc

let subst_elem x z = function
  | LineActBuffer { op; args; phi } ->
      LineActBuffer
        {
          op;
          args = List.map (subst_name_qv x z) args;
          phi = subst_prop_instance x (AVar z) phi;
        }
  | LineAct { op; args } ->
      LineAct { op; args = List.map (subst_name_qv x z) args }
  | PlanSe se ->
      let { op; vs; phi } = subst_sevent_instance x (AVar z) se in
      PlanSe { op; vs; phi }
  | LineStarInv cs ->
      LineStarInv (SFA.CharSet.map (subst_sevent_instance x (AVar z)) cs)
  | LineStar r -> LineStar (SFA.subst_regex_instance x (AVar z) r)

let subst_plan x z = List.map (subst_elem x z)

(* module PlanElemSet = Set.Make (struct *)
(*   type t = plan_elem *)

(*   let compare = compare_plan_elem *)
(* end) *)

let gather_actions plan =
  let l =
    List.filter
      (fun elem ->
        match elem with
        | LineAct _ -> true
        | LineActBuffer _ -> _die [%here]
        | _ -> false)
      plan
  in
  l

(* let left_most_se plan = *)
(*   let rec aux (pre, rest) = *)
(*     match rest with *)
(*     | [] -> None *)
(*     | PlanSe cur :: post -> Some (pre, cur, post) *)
(*     | elem :: post -> aux (pre @ [ elem ], post) *)
(*   in *)
(*   aux ([], plan) *)

(* let right_most_se plan = *)
(*   let* pre, cur, post = left_most_se (List.rev plan) in *)
(*   (\* let () = if !counter >= 2 then _die [%here] in *\) *)
(*   Some (List.rev post, cur, List.rev pre) *)

let exactly_match se plan =
  let () =
    Pp.printfBold "exactly_match:"
      (spf "%s in %s" (layout_sevent se) (omit_layout_plan plan))
  in
  let rec aux (pre, post) =
    match post with
    | [] -> []
    | (LineAct _ as mid) :: post -> (
        match smart_and_se se mid with
        | None -> aux (pre @ [ mid ], post)
        | Some mid' -> (
            match mid' with
            | LineAct _ | LineActBuffer _ ->
                [ (pre, mid', post) ] @ aux (pre @ [ mid ], post)
            | _ -> aux (pre @ [ mid ], post)))
    | mid :: post -> aux (pre @ [ mid ], post)
  in
  aux ([], plan)
